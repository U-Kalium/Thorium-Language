// Variable decleration

let a f32       // let for constant

var b f32       // var for mutable

var c           // type can be infered


// Variable assignment

b = 3.0         // either done by an equal operand

c {             // or simply a body `{}` with a return statement
    return 4
}

//  variable decleration and assignment

let foo string = "hello world"
let bar f32 {
    return 3.14
}

// Functions and Lambdas


let add (lhs i32, rhs i32) i32 {
    finish lhs + rhs
}
// writing a function like this without named arguments
// defaults the arguments to arg0, arg1 ....
let minus (i32, i32) i32 {
    finish arg0 - arg1
}

// Primitive types

// Integers
let a int                           // is the same as i32 by default it is used when not specific about length
let b i128                          // 128 bit signed integer `u128` for unsigned
let c i64                           // 64 bit signed integer `u64` for unsigned
let d i32                           // 32 bit signed integer `u32` for unsigned
let e i16                           // 16 bit signed integer `u16` for unsigend
let f i8                            // 8  bit signed integer `u8 ` for unsigend

// Floats
let g float                         // is the same as f32 by default it is used when not specific about length
let h f32                           // 32 bit float
let i f64                           // 64 bit float

// Char
let j char = 'j'                    // utf 8 character denoted by single qoutes

// Arrays
/*
    the type of the array is declared with [] on the left
    accessing it would have [] on the right e.g. numbers[2]
*/
let k [dyn]int                      // dynamic array denoted by [dyn]
let l [10]int                       // fixed size arrat denoted by [type]

// Type declerations

type number i32             // the ident after `type` can now be used anywhere a type is usually placed as it is like an alies to f32 (note: it is a destinct type from f32)

// Structs

let john {           // this would be declaring a variable with an anonymouse struct type. 
    age int
    height f32
    name string
}
let mike {                  // this will be infered to Person although if another struct has the same members type parameter will be needed
    age     = 10
    height  = 1.7
    name    = "mike
}

// default values

let john {           // this is how you would most likely assign values to an anonymouse struct
    age = 10
    height f32 = 1.9
    name = "john"
}



// Methods, Generics and Interfaces

/*
    interfaces are not types and therefore can not be used in type declerations
    they are mainly used for generics.
*/

// a method is a normal funciton where the first argument is named self
// this automaticcally allows it to be used as methods 
let age_up(self &mut Person, amount int) {

}

mike.age_up(10)

interface Ageable {                                     // An interface can be a list of methods and properties with `self` being a replacement to whatever the type is
    age_up(&mut self, int)
    age int                                             // properties don't have to be prefaced
}

/*
    Simillar to Go you do not have to explicitly implement the interface. 
    As person has a method with the same name and simillar type it implicitly implements the interface 
*/

let age_all<T Ageable>(things) {                          // the generic arguments go in the <> brackets and are declared the same as arguments but type is replaced with an interface

}

interface Growable {
    grow(&mut self, f32)
}

let grow(self &mut Perdson, length f32) {
    height += length                                     // you can use the members of self without prefacing them 
}

let age_and_grow<T Ageable & Growable>(things []T) {            // If you need something to satisfy multiple Interfaces

}

interface Developable {                                 // Alternatively you could create another interface with the a list of interfaces
    Growable
    Ageable
}

// Inheritence/Composition

/*
    Stolen from jai. rather than allow for direct inheritence you can create a strruct with one member being the "parent" type. 
    but by using the `has` keyowrd the members of the "parent" act like regular members. This also allows for other syntax sugering
*/

type Entity struct {                                    // can be thought of as a base class
    id i64
    is_shown bool
}

let update<&mut Entity>() {

}

type Character struct {
    has Entity
    name string
}

/* Equivelent to
    type Character struct {
        enitiy Entity
        name string
    }
*/

let character1 Character {                      // Initialised as if Entity members are part of Charcter
    id = 0
    is_shown = trueUnion
    name = "john"
}

character1.update()

/* Equivelent to

    let charcter1 Chracter {
        entity Entity {
            id = 0
            is_shown = true
        }
        name = "john"
    }

    character1.entity.update()

*/


/*
    loops
*/

// foreach loop
loop i in array {

}

// While loops
loop true {

}

loop is_looping {

}

loop 10 == 9 {
    
}

// for loop
loop var i = 0; i < 10; i += 1 {

}

// tagged unions/enums

type MarriageStatus Enum {
    Married Partner         // the varient name followed by type
}

// anonymouse
string|u32|Person